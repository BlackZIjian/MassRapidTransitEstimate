#概要设计说明书
##引言
###编写目的
本文档为开发人员在开发前对于开发流程的概要设计，目的在于开发程序时能够更加快速开发，做到工作不冗余，将耦合度降到最低。
##总体设计
###核心算法
####数据输入
由于初始数据量大，不可能做到直接读入通过网络上传到服务器，我们讨论决定采用将原始数据XML文件转为二进制文件，再采用二进制文件压缩算法压缩后上传到服务器经服务器处理。

	XML转二进制算法：
	1.数据输入具有i,j,k,p四个字段（字段含义见
[需求分析](/需求分析报告.md#数据导入)
​	
	)考虑到数据位数以及数据范围，最终敲定对应位数如下：
	i----6位
	j----6位
	k----4位
	p----32位
	每组数据共48位.
	
	转换算法为异步加载xml文件，读入的每条数据到内存，截取掉无用位数段后写入到二进制文件，释放掉内存，直到所有数据都完后关闭XML文件和二进制文件。
<br>
​	
	压缩文件算法为哈夫曼树算法
	查找每个符号的通用程度，我们建立一个未压缩数据的柱状图；通过递归拆分这个柱状图为两部分来创建一个二叉树，每个递归的一半应该和另一半具有同样的权
	（权是∑NK =1符号数k, N是分之中符号的数量，符号数k是符号k出现的次数）
	编码器使用这棵树来找到每个符号最优的表示方法
	解码器使用这棵树唯一的标识在压缩流中每个编码的开始和结束，其通过在读压缩数据位的时候自顶向底的遍历树，选择基于数据流中的每个独立位的分支，一旦一个
	到达叶子节点，解码器知道一个完整的编码已经读出来了。
	
	举例
	根据符号频率，哈夫曼编码器生成哈夫曼树
![](/)
​	
和相应的编码表示

![](/)

	压缩后的数据流是24位（三个字节），原来是80位（10个字节）。当然，我应该存储哈夫曼树，这样解码器就能够解码出对应的压缩流了，这就使得该例子
	中的真正数据流比输入的流数据量大。这是相对较短的数据上的副作用。对于大数据量来说，上面的哈夫曼树就不占太多比例了

![](/)

	解码的时候，从上到下遍历树，为压缩的流选择从左/右分支，每次碰到一个叶子节点的时候，就可以将对应的字节写到解压输出流中，然后再从根开始遍历。

算法流程图

![](/)

####数据处理

采用遗传算法来进行最优搜索

	遗传算法（Genetic Algorithm）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。
	遗传算法是从代表问题可能潜在的解集的一个种群（population）开始的，而一个种群则由经过基因（gene）编码的一定数目的个体(individual)组成。每个个体
	实际上是染色体(chromosome)带有特征的实体。染色体作为遗传物质的主要载体，即多个基因的集合，其内部表现（即基因型）是某种基因组合，它决定了个体的形
	状的外部表现，如黑头发的特征是由染色体中控制这一特征的某种基因组合决定的。因此，在一开始需要实现从表现型到基因型的映射即编码工作。由于仿照基因编码
	的工作很复杂，我们往往进行简化，如二进制编码，初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解，在每
	一代，根据问题域中个体的适应度（fitness）大小选择（selection）个体，并借助于自然遗传学的遗传算子（genetic operators）进行组合交叉（crossover）
	和变异（mutation），产生出代表新的解集的种群。这个过程将导致种群像自然进化一样的后生代种群比前代更加适应于环境，末代种群中的最优个体经过解码
	（decoding），可以作为问题近似最优解。
	
	对于一个求函数最大值的优化问题(求函数最小值也类同)，一般可以描述为下列数学规划模型：式中x为决策变量，式2-1为目标函数式，式2-2、2-3为约束条件，
	U是基本空间，R是U的子集。满足约束条件的解X称为可行解，集合R表示所有满足约束条件的解所组成的集合，称为可行解集合。

![](/)


遗传算法的基本运算过程如下：

+ a)初始化：设置进化代数计数器t=0，设置最大进化代数T，随机生成M个个体作为初始群体P(0)。

+ b)个体评价：计算群体P(t)中各个个体的适应度。

+ c)选择运算:将选择算子作用于群体。选择的目的是把优化的个体直接遗传到下一代或通过配对交叉产生新的个体再遗传到下一代。选择操作是建立在群体中个体的适应度评估基础上的。

+ d)交叉运算：将交叉算子作用于群体。遗传算法中起核心作用的就是交叉算子。

+ e)变异运算：将变异算子作用于群体。即是对群体中的个体串的某些基因座上的基因值作变动。
  群体P(t)经过选择、交叉、变异运算之后得到下一代群体P(t+1)。

+ f)终止条件判断:若t=T,则以进化过程中所得到的具有最大适应度个体作为最优解输出，终止计算。

#####算法举例：

问题定义如下：
求下述二元函数的最大值

![](/)

+ 个体编码

  遗传算法的运算对象是表示个体的符号串，所以必须把变量 x1, x2 编码为一种符号串。本题中，用无符号二进制整数来表示。因 x1, x2 为 0 ~ 7之间的整数，所以分别用3位无符号二进制整数来表示，将它们连接在一起所组成的6位无符号二进制数就形成了个体的基因型，表示一个可行解。例如，基因型 X＝101110 所对应的表现型是：x＝[ 5，6 ]。个体的表现型x和基因型X之间可通过编码和解码程序相互转换。

+ 初始群体的产生

  遗传算法是对群体进行的进化操作，需要给其淮备一些表示起始搜索点的初始群体数据。本例中，群体规模的大小取为4，即群体由4个个体组成，每个个体可通过随机方法产生。如：011101，101011，011100，111001

+ 适应度汁算

  遗传算法中以个体适应度的大小来评定各个个体的优劣程度，从而决定其遗传机会的大小。本例中，目标函数总取非负值，并且是以求函数最大值为优化目标，故可直接利用目标函数值作为个体的适应度。

+ 选择运算

  选择运算(或称为复制运算)把当前群体中适应度较高的个体按某种规则或模型遗传到下一代群体中。一般要求适应度较高的个体将有更多的机会遗传到下一代群体中本例中，我们采用与适应度成正比的概率来确定各个个体复制到下一代群体中的数量。其具体操作过程是：
  + 先计算出群体中所有个体的适应度的总和  ?fi  ( i=1.2,…,M );

  + 其次计算出每个个体的相对适应度的大小 fi / ?fi ，它即为每个个体被遗传到下一代群体中的概率，
  + 每个概率值组成一个区域，全部概率值之和为1；
  + 最后再产生一个0到1之间的随机数，依据该随机数出现在上述哪一个概率区域内来确定各个个体被选中的次数。

![](/)

+ 交叉运算

  交叉运算是遗传算法中产生新个体的主要操作过程，它以某一概率相互交换某两个个体之间的部分染色体。
  本例采用单点交叉的方法，其具体操作过程是：
  + 先对群体进行随机配对；
  + 其次随机设置交叉点位置；
  + 最后再相互交换配对染色体之间的部分基因。 

![](/)

+ 变异运算

  变异运算是对个体的某一个或某一些基因座上的基因值按某一较小的概率进行改变，它也是产生新个体的一种操作方法。
  本例中，我们采用基本位变异的方法来进行变异运算，其具体操作过程是：
  + 首先确定出各个个体的基因变异位置，下表所示为随机产生的变异点位置，其中的数字表示变异点设置在该基因座处；
  + 然后依照某一概率将变异点的原有基因值取反。
    ![](/)

  对群体P(t)进行一轮选择、交叉、变异运算之后可得到新一代的群体p(t+1)。
  ![](/)

  从上表中可以看出，群体经过一代进化之后，其适应度的最大值、平均值都得到了明显的改进。事实上，这里已经找到了最佳个体“111111”。       
  [注意]      
  需要说明的是，表中有些栏的数据是随机产生的。这里为了更好地说明问题，我们特意选择了一些较好的数值以便能够得到较好的结果，而在实际运算过程中有可能需要一定的循环次数才能达到这个最优结果。

####数据输出
采用点阵模糊拼接的算法，取一定范围内的点值采用高斯模糊的做法求出模糊值，采用对应颜色基础值输出，再根据建设密度叠加相应的颜色强度，最终输出一张可视图。
###系统总体架构设计

![](/)

###软件架构设计
### 数据输入

####设计类图

![](/)

####主要类说明：
#####DataStream数据流类

定义数据结构用以在内存中以流的形式存储数据

#####成员变量：
length：数据流的长度
type：数据流的编码格式
data：数据流
open_type：只读或读写
#####函数方法：
open():新建一个数据流
virtual read():读入数据
virtual write():输出数据
close():关闭数据流并释放

#####InputDataStream输入数据流类
继承DataStream，打开方式为只读

#####OutputDataStream输出数据流
继承DataStream，打开方式为读写

#####Form输入表单类

用户与系统进行交互的UI类，处理数据搜集者的输入信息

#####成员变量
input_uis：包括多个数据输入的UI组件（与用户交互组件）
datas：用户输入的数据
#####函数方法
Bind()：将用户输入绑定到数据数组
Submit():将数据提交

#####DataChanger数据格式修改器

修改数据的存储格式

#####成员变量
source_data:修改前数据
result_data:修改后数据
#####函数方法
read():读入数据
output():输出结果数据
virtual Format():将数据转码
virtual UnFormat()：将数据解码

##### FormatChanger转码器

继承DataChanger数据格式修改器

##### PatchChanger压缩器

继承DataChanger数据格式修改器



##### DataSend数据发送类

发送数据

##### 成员变量

source_data:原数据

router:发送的url

##### 函数方法

Send():发送数据

#### 接口设计说明

##### 模块外接口

接口名：Bind()，绑定数据

功能：将用户输入的数据绑定到模块内部

参数：用户输入的数据

返回值：无



接口名：Submit()，提交数据

功能：将输入的数据提交到服务器

参数：无

返回值：当前已提交的数据量



##### 模块内接口

接口名：InputStream::Open()

功能：创建一个可存储已知数据的数据流，不可修改

参数：数据长度，数据解码类型，数据

返回值：InputStream实例



接口名：InputStream::Close()

功能：关闭一个数据流并释放内存

参数：无

返回值：无



接口名：DataChanger::Read()

功能：创建一个转码器，并进行转码

参数：原数据

返回值：DataChanger实例



接口名：DataChanger::Output()

功能：取出转码后的结果并释放内存

参数：无

返回值：转码后数据



接口名：OutputStream::Open()

功能：创建一个空的数据流对象，可以写入

参数：数据类型

返回值：OutputStream实例



接口名：OutputStream::Write()

功能：将数据写入到可写入的数据流中

参数：数据，数据长度

返回值：无



接口名：OutputStream::Close()

功能：关闭一个数据流，并释放内存

参数：无

返回值：无



接口名：DataSend::Send()

功能：向模块外部发送一段数据，以路由的方式

参数：数据

返回值：发送是否成功

### 数据处理

#### 设计类图

![](/)

#### 时序图

![](/)

#### 类说明

##### DataHundleInterface数据处理接口类

数据处理模块对外的接口

##### 成员变量

data:接收到的数据

##### 函数方法

DataHundle():开始数据处理



##### Gold上帝类

存储管理和控制每一代的群体

##### 成员变量

groups:群体数组，存储每一代的群体数据

##### 函数方法

InitGroup()：创建初代群体

StartSire():开始繁殖遗传



##### Group群体类

遗传算法中的一代群体

##### 成员变量

indivituals:群体中的全部个体的数组

generate:群体的代数

fitness:群体的适应度

type:群体的适应度目标类型标记

##### 函数方法

SelectExcute():自然选择运算，在群体中按比例选择出适应的个体



##### Indivitual个体类

遗传算法中群体中的个体

##### 成员变量

pos_x:个体固定值，所处土地单元矩阵的横坐标

pos_y:个体固定值，所处土地单元矩阵的纵坐标

land_type:个体固定值，土地规划类型

is_meet_plan：个体表现型，是否满足规划类型

cons_density：个体表现型，建设密度

chromosome：个体对应的染色体

fitness:个体的适应度

##### 函数方法

VaruteExcute()：变异运算，使个体的染色体发生随机的变异



##### chromosome染色体类

遗传算法中个体所拥有的染色体

##### 成员变量

gene：染色体的基因，以二进制编码存储

##### 函数方法

GeneExpression()：基因表达，将基因转换成表现型



##### FitnessCalculate适应度计算类

以特定的规则计算个体适应度

##### 成员变量

rule：计算的规则

##### 函数方法

Excute():计算适应度



#### 接口设计

接口名：DataHundle()

功能：开始处理数据

参数：数据源文件

返回值：输出数据



接口名：Gold::getInstance()

功能：获取上帝的单例，如果没有则新建

参数：无

返回值：Gold类实例



接口名：Gold::InitGroups()

功能：创建初始群体

参数：数据源

返回值：群体数量



接口名：Gold::GenerateExcute()

功能：开始遗传进化

参数：遗传代数

返回值：无



接口名：Group::SelectExcute()

功能：对群体进行一代的自然选择

参数：无

返回值：无



接口名：Indivitual::VarationExcute()

功能：对个体进行随机的变异计算

参数：无

返回值：无



接口名：Chromosome::GeneExpression()

功能：对染色体的基因表达，将二进制编码解析成决策变量

参数：无

返回值：无



接口名：FitnessExcute()

功能：根据规则计算个体的适应度

参数：Inivitual实例

返回值：适应度



### 数据输出

#### 设计类图

![]()

#### 主要类说明

##### DataStream数据流类

定义数据结构用以在内存中以流的形式存储数据

##### 成员变量：

length：数据流的长度
type：数据流的编码格式
data：数据流
open_type：只读或读写

##### 函数方法：

open():新建一个数据流
virtual read():读入数据
virtual write():输出数据
close():关闭数据流并释放



##### InputDataStream输入数据流类

继承DataStream，打开方式为只读



##### OutputDataStream输出数据流

继承DataStream，打开方式为读写



##### DataOutput数据输出类

将结果数据以一定的格式输出到文件

##### 成员变量

data_type：数据格式

data：输出的数据

data_length:数据长度

##### 函数方法

Output():将数据输出



##### DataChanger数据格式修改器

修改数据的存储格式

##### 成员变量

source_data:修改前数据
result_data:修改后数据

##### 函数方法

read():读入数据
output():输出结果数据
virtual Format():将数据转码
virtual UnFormat()：将数据解码



##### FormatChanger转码器

继承DataChanger数据格式修改器



##### PatchChanger压缩器

继承DataChanger数据格式修改器



##### ImageChanger图片转码器

继承DataChanger数据格式修改器



##### DataReciver数据接收类

接收数据

##### 成员变量

data:收到的数据地址

router:本地路由信息

##### 函数方法

StartListener():开始监听数据



#### 接口设计说明

##### 模块外接口

接口名：StartListener()，开始监听数据

功能：开始监听数据，在停止前若收到了数据信息则绑定到数据地址上

参数：监听时间（-1表示手动停止）

返回值：无



接口名：DataOutput(),输出数据

功能：向指定路径输出数据

参数：路径

返回值：无



##### 模块内接口

接口名：InputStream::Open()

功能：创建一个可存储已知数据的数据流，不可修改

参数：数据长度，数据解码类型，数据

返回值：InputStream实例



接口名：InputStream::Close()

功能：关闭一个数据流并释放内存

参数：无

返回值：无



接口名：DataChanger::Read()

功能：创建一个转码器，并进行转码

参数：原数据

返回值：DataChanger实例



接口名：DataChanger::Output()

功能：取出转码后的结果并释放内存

参数：无

返回值：转码后数据



接口名：OutputStream::Open()

功能：创建一个空的数据流对象，可以写入

参数：数据类型

返回值：OutputStream实例



接口名：OutputStream::Write()

功能：将数据写入到可写入的数据流中

参数：数据，数据长度

返回值：无



接口名：OutputStream::Close()

功能：关闭一个数据流，并释放内存

参数：无

返回值：无

### 异常处理设计

#### 数据输入

#### 模块外异常：

##### 绑定数据：

用户输入需满足格式，不满足格式的输出是不被允许的

##### 提交：

输入表单类中的数据需满足格式，不满足格式需报错并清空数据重新输入

##### 打开数据流：

检查可用内存并确保有足够的内存存储数据，如不够，弹出内存不足提示，要求用户重选数据处理异步分割量

##### 发送数据：

与目标路由建立连接，若无法连接，报网络错误，若可连接无法发送数据，报服务器未开启监听

#### 模块内部错误：

（第一次迭代针对遇到Bug添加异常处理方法）

##### 数据流访问冲突：

创建数据流时，建立繁忙标志，阻止多次访问带来的访问冲突

##### 转码器未及时释放：

规定转码器的生命周期，在取出数据后自动释放

#### 数据处理

#### 模块外异常

##### 群体数据量不足：

创建上帝时要求数据输入量足够，若不足，报群体数据量不足

##### 数据输入格式不对引起数据异常

解析数据时，若发现不符要求的异常数据，报数据格式错误

##### 适应度计算规则无结果

由规则输入不合理导致短时间内无法得到适应度，要求重新输入适应度规则

#### 模块内错误

# 第一次迭代发现重大设计缺陷，此处修改

将每代全部的群体存储到上帝类的群体数组时，出现群体数过多造成内存溢出，重新规划后采用异步输出的方式，在每代计算完成后，输出信息到硬盘，减少内存占用。

#### 数据输出

#### 模块外异常

##### 接收到数据格式不符

创建输出数据流时检查格式是否符合，若不符，拒绝接受此段数据并报错

##### 数据处理后数据结果异常

数据输出前检查数据结果，若异常，报处理失败错误

#### 模块内部错误：

（第一次迭代针对遇到Bug添加异常处理方法）

##### 数据流访问冲突：

创建数据流时，建立繁忙标志，阻止多次访问带来的访问冲突

##### 转码器未及时释放：

规定转码器的生命周期，在取出数据后自动释放







